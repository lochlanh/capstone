{"ast":null,"code":"import { createMemoryHistory, parsePath } from 'history';\nimport PropTypes from 'prop-types';\nimport React from 'react';\n\nfunction k() {\n  k = Object.assign || function (a) {\n    for (var b = 1; b < arguments.length; b++) {\n      var c = arguments[b],\n          d;\n\n      for (d in c) Object.prototype.hasOwnProperty.call(c, d) && (a[d] = c[d]);\n    }\n\n    return a;\n  };\n\n  return k.apply(this, arguments);\n}\n\nvar l = \"production\" !== process.env.NODE_ENV ? function (a) {\n  return Object.freeze(a);\n} : function (a) {\n  return a;\n};\n\nfunction m(a, b) {\n  if (!a) throw Error(b);\n}\n\nvar n = React.createContext();\n\"production\" !== process.env.NODE_ENV && (n.Consumer.displayName = \"Location.Consumer\", n.Provider.displayName = \"Location.Provider\");\nvar p = React.createContext({\n  outlet: null,\n  params: l({}),\n  pathname: \"\",\n  route: null\n});\n\"production\" !== process.env.NODE_ENV && (p.Consumer.displayName = \"Route.Consumer\", p.Provider.displayName = \"Route.Provider\");\n\nfunction q(a) {\n  var b = a.children,\n      c = a.initialEntries,\n      d = a.initialIndex;\n  a = a.timeout;\n  var e = React.useRef(null);\n  null == e.current && (e.current = createMemoryHistory({\n    initialEntries: c,\n    initialIndex: d\n  }));\n  return React.createElement(r, {\n    children: b,\n    history: e.current,\n    timeout: a\n  });\n}\n\n\"production\" !== process.env.NODE_ENV && (q.displayName = \"MemoryRouter\", q.propTypes = {\n  children: PropTypes.node,\n  timeout: PropTypes.number,\n  initialEntries: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    pathname: PropTypes.string,\n    search: PropTypes.string,\n    hash: PropTypes.string,\n    state: PropTypes.object,\n    key: PropTypes.string\n  })])),\n  initialIndex: PropTypes.number\n});\n\nfunction t(a) {\n  var b = a.to,\n      c = a.replace;\n  c = void 0 === c ? !1 : c;\n  a = a.state;\n  u()(b, {\n    replace: c,\n    state: a\n  });\n  return null;\n}\n\n\"production\" !== process.env.NODE_ENV && (t.displayName = \"Navigate\", t.propTypes = {\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    pathname: PropTypes.string,\n    search: PropTypes.string,\n    hash: PropTypes.string\n  })]).isRequired,\n  replace: PropTypes.bool,\n  state: PropTypes.object\n});\n\nfunction v() {\n  return w();\n}\n\n\"production\" !== process.env.NODE_ENV && (v.displayName = \"Outlet\", v.propTypes = {});\n\nfunction x() {\n  return null;\n}\n\n\"production\" !== process.env.NODE_ENV && (x.displayName = \"Redirect\", x.propTypes = {\n  children: function (a, b) {\n    if (null != a[b]) return Error(\"A <Redirect> should not have child routes; they will never be rendered.\");\n  },\n  from: PropTypes.string,\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    pathname: PropTypes.string,\n    search: PropTypes.string,\n    hash: PropTypes.string\n  })])\n});\n\nfunction y(a) {\n  return a.element;\n}\n\n\"production\" !== process.env.NODE_ENV && (y.displayName = \"Route\", y.propTypes = {\n  children: PropTypes.node,\n  element: PropTypes.element,\n  path: PropTypes.string\n});\n\nfunction z(a) {\n  return a();\n}\n\nvar A = React.useTransition || function () {\n  return [z, !1];\n};\n\nfunction r(a) {\n  var b = a.children;\n  b = void 0 === b ? null : b;\n  var c = a.history;\n  a = a.timeout;\n  var d = void 0 === a ? 2E3 : a,\n      e = React.useState(c.location);\n  a = e[0];\n  var f = e[1];\n  d = A({\n    timeoutMs: d\n  });\n  var g = d[0];\n  d = d[1];\n  e = React.useRef(!1);\n  React.useContext(n) ? \"production\" !== process.env.NODE_ENV ? m(!1, \"You cannot render a <Router> inside another <Router>. You never need more than one.\") : m(!1) : void 0;\n  e.current || (e.current = !0, c.listen(function (a) {\n    var b = a.location;\n    g(function () {\n      f(b);\n    });\n  }));\n  return React.createElement(n.Provider, {\n    children: b,\n    value: {\n      history: c,\n      location: a,\n      pending: d\n    }\n  });\n}\n\n\"production\" !== process.env.NODE_ENV && (r.displayName = \"Router\", r.propTypes = {\n  children: PropTypes.node,\n  history: PropTypes.shape({\n    action: PropTypes.string,\n    location: PropTypes.object,\n    push: PropTypes.func,\n    replace: PropTypes.func,\n    go: PropTypes.func,\n    listen: PropTypes.func,\n    block: PropTypes.func\n  }),\n  timeout: PropTypes.number\n});\n\nfunction B(a) {\n  var b = a.basename;\n  b = void 0 === b ? \"\" : b;\n  var c = a.caseSensitive;\n  c = void 0 === c ? !1 : c;\n  a = C(a.children);\n  return D(a, b, c);\n}\n\n\"production\" !== process.env.NODE_ENV && (B.displayName = \"Routes\", B.propTypes = {\n  basename: PropTypes.string,\n  caseSensitive: PropTypes.bool,\n  children: PropTypes.node\n});\n\nfunction C(a) {\n  var b = [];\n  React.Children.forEach(a, function (a) {\n    if (React.isValidElement(a)) {\n      var c = a.props,\n          e = c.children,\n          f = c.from,\n          g = c.path;\n      c = c.to;\n      a.type === React.Fragment ? b.push.apply(b, C(e)) : (g = g || f || \"/\", c ? a = {\n        path: g,\n        redirectTo: c\n      } : (a = {\n        path: g,\n        element: a\n      }, e = C(e), e.length && (a.children = e)), b.push(a));\n    }\n  });\n  return b;\n}\n\nfunction E() {\n  return React.useContext(n).location;\n}\n\nfunction u() {\n  var a = React.useContext(n),\n      b = a.history,\n      c = a.pending,\n      d = React.useContext(p).pathname;\n  null == b ? \"production\" !== process.env.NODE_ENV ? m(!1, \"navigation may be used only in the context of a <Router> component\") : m(!1) : void 0;\n  return React.useCallback(function (a, f) {\n    var e = void 0 === f ? {} : f;\n    f = e.replace;\n    e = e.state;\n    \"number\" === typeof a ? b.go(a) : (a = F(a, d), b[f || c ? \"replace\" : \"push\"](a, e));\n  }, [b, c, d]);\n}\n\nfunction w() {\n  return React.useContext(p).outlet;\n}\n\nfunction G(a) {\n  var b = React.useContext(p).pathname;\n  return React.useMemo(function () {\n    return F(a, b);\n  }, [a, b]);\n}\n\nvar I, J;\n\"production\" !== process.env.NODE_ENV && (I = {}, J = function (a, b, c) {\n  if (!b && !I[a]) if (I[a] = !0, \"production\" !== process.env.NODE_ENV) {\n    \"undefined\" !== typeof console && console.warn(c);\n\n    try {\n      throw Error(c);\n    } catch (d) {}\n  } else void 0;\n});\n\nfunction D(a, b, c) {\n  void 0 === b && (b = \"\");\n  void 0 === c && (c = !1);\n  var d = React.useContext(p),\n      e = d.params,\n      f = d.pathname;\n  d = d.route;\n\n  if (J) {\n    var g = d && d.path;\n    J(f, !d || d.path.endsWith(\"*\"), 'You rendered descendant <Routes> (or called `useRoutes`) at \"' + f + '\" (under <Route path=\"' + (g + '\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won\\'t match anymore and therefore the child routes will never render.\\n\\nPlease change the parent <Route path=\"') + (g + '\"> to <Route path=\"' + g + '/*\">.'));\n  }\n\n  b = b ? K([f, b]) : f;\n  d = u();\n  var H = E();\n  g = React.useMemo(function () {\n    return L(a, H, b, c);\n  }, [a, H, b, c]);\n  if (!g) return null;\n  var h = g.find(function (a) {\n    return null != a.route.redirectTo;\n  });\n  return h ? (g = h.params, f = F(h.route.redirectTo, f), h = f.pathname, /:\\w+/.test(h) && (f = k({}, f, {\n    pathname: M(h, g)\n  })), d(f, {\n    replace: !0\n  }), null) : g.reduceRight(function (a, c) {\n    var d = c.pathname,\n        f = c.route;\n    return React.createElement(p.Provider, {\n      children: f.element,\n      value: {\n        outlet: a,\n        params: l(k({}, e, {}, c.params)),\n        pathname: K([b, d]),\n        route: f\n      }\n    });\n  }, null);\n}\n\nfunction L(a, b, c, d) {\n  function e(a) {\n    a = g[a];\n    var b = a[1];\n    if (N(a[0], !0, d)[0].test(f)) return {\n      v: b.map(function (a, c) {\n        c = b.slice(0, c + 1);\n        c = K(c.map(function (a) {\n          return a.path;\n        }));\n        var e = N(c, !1, d);\n        c = e[1];\n        e = f.match(e[0]);\n        return {\n          params: O(c, e.slice(2)),\n          pathname: \"/\" + e[1],\n          route: a\n        };\n      })\n    };\n  }\n\n  void 0 === c && (c = \"\");\n  void 0 === d && (d = !1);\n  \"string\" === typeof b && (b = parsePath(b));\n  c = c.replace(/^\\/+|\\/+$/g, \"\");\n  var f = b.pathname.slice(1);\n  if (c) if (c === f) f = \"\";else if (f.startsWith(c)) f = f.slice(c.length).replace(/^\\/+/, \"\");else return null;\n  var g = P(a);\n  Q(g);\n\n  for (a = 0; a < g.length; ++a) if (b = e(a), \"object\" === typeof b) return b.v;\n\n  return null;\n}\n\nfunction P(a, b, c, d, e) {\n  void 0 === b && (b = []);\n  void 0 === c && (c = \"\");\n  void 0 === d && (d = []);\n  void 0 === e && (e = []);\n  a.forEach(function (a, g) {\n    var f = K([c, a.path]),\n        h = d.concat(a);\n    g = e.concat(g);\n    b.push([f, h, g]);\n    a.children && P(a.children, b, f, h, g);\n  });\n  return b;\n}\n\nvar R = /^:\\w+$/,\n    S = 2,\n    T = 1,\n    U = 10,\n    V = -2;\n\nfunction W(a) {\n  return \"*\" === a;\n}\n\nfunction X(a) {\n  a = a.split(\"/\");\n  var b = a.length;\n  a.some(W) && (b += V);\n  return a.filter(function (a) {\n    return !W(a);\n  }).reduce(function (a, b) {\n    return a + (R.test(b) ? S : \"\" === b ? T : U);\n  }, b);\n}\n\nfunction Q(a) {\n  var b = a.reduce(function (a, b) {\n    b = b[0];\n    a[b] = X(b);\n    return a;\n  }, {});\n  a.sort(function (a, d) {\n    var c = a[2];\n    a = b[a[0]];\n    var f = d[2];\n    d = b[d[0]];\n    return a !== d ? d - a : Y(c, f);\n  });\n}\n\nfunction Y(a, b) {\n  return a.length === b.length && a.slice(0, -1).every(function (a, d) {\n    return a === b[d];\n  }) ? a[a.length - 1] - b[b.length - 1] : 0;\n}\n\nfunction N(a, b, c) {\n  var d = [],\n      e = \"^(\" + a.replace(/^\\/+/, \"\").replace(/\\*\\//g, \"\").replace(/\\/?\\*?$/, \"\").replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\").replace(/:(\\w+)/g, function (a, b) {\n    d.push(b);\n    return \"([^\\\\/]+)\";\n  }) + \")\";\n  a.endsWith(\"*\") ? (a.endsWith(\"/*\") && (e += \"\\\\/?\"), d.push(\"*\"), e += \"(.*)\") : b && (e += \"\\\\/?\");\n  b && (e += \"$\");\n  return [new RegExp(e, c ? void 0 : \"i\"), d];\n}\n\nfunction O(a, b) {\n  return a.reduce(function (a, d, e) {\n    a[d] = b[e];\n    return a;\n  }, {});\n}\n\nfunction K(a) {\n  return a.join(\"/\").replace(/\\/\\/+/g, \"/\");\n}\n\nfunction Z(a, b) {\n  var c = b.replace(/\\/+$/, \"\").replace(/\\/\\/+/g, \"/\").split(\"/\");\n  a.replace(/\\/\\/+/g, \"/\").split(\"/\").forEach(function (a) {\n    \"..\" === a ? 1 < c.length && c.pop() : \".\" !== a && c.push(a);\n  });\n  return 1 < c.length ? K(c) : \"/\";\n}\n\nfunction F(a, b) {\n  void 0 === b && (b = \"/\");\n  var c = \"string\" === typeof a ? parsePath(a) : a;\n  a = c.pathname;\n  var d = c.search;\n  d = void 0 === d ? \"\" : d;\n  c = c.hash;\n  c = void 0 === c ? \"\" : c;\n  return {\n    pathname: a ? a.startsWith(\"/\") ? Z(a, \"/\") : Z(a, b) : b,\n    search: d,\n    hash: c\n  };\n}\n\nfunction M(a, b) {\n  void 0 === b && (b = {});\n  return a.replace(/:(\\w+)/g, function (a, d) {\n    return b[d] || \":\" + d;\n  }).replace(/\\*$/, function (a) {\n    return b[a] || a;\n  });\n}\n\nfunction useBlocker(a, b) {\n  void 0 === b && (b = !0);\n  var c = React.useContext(n).history;\n  null == c ? \"production\" !== process.env.NODE_ENV ? m(!1, \"navigation blocking may be used only in the context of a <Router> component\") : m(!1) : void 0;\n  React.useEffect(function () {\n    if (b) {\n      var d = c.block(function (b) {\n        var c = k({}, b, {\n          retry: function () {\n            d();\n            b.retry();\n          }\n        });\n        a(c);\n      });\n      return d;\n    }\n  }, [c, b, a]);\n}\n\n;\n\nfunction useHref(a) {\n  a = G(a);\n  var b = React.useContext(n).history;\n  null == b ? \"production\" !== process.env.NODE_ENV ? m(!1, \"href resolution may be used only in the context of a <Router> component\") : m(!1) : void 0;\n  return b.createHref(a);\n}\n\n;\n\nfunction useMatch(a) {\n  var b = E();\n  a = G(a);\n  return b.pathname === a.pathname;\n}\n\n;\n\nfunction useParams() {\n  return React.useContext(p).params;\n}\n\n;\nexport { q as MemoryRouter, t as Navigate, v as Outlet, x as Redirect, y as Route, r as Router, B as Routes, C as createRoutesFromChildren, M as generatePath, L as matchRoutes, F as resolveLocation, useBlocker, useHref, E as useLocation, useMatch, u as useNavigate, w as useOutlet, useParams, G as useResolvedLocation, D as useRoutes };","map":{"version":3,"mappings":"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","names":["Object","readOnly","hasOwnProperty","NODE_ENV","a","obj","arguments","invariant","process","Error","React","LocationContext","n","RouteContext","outlet","params","pathname","route","MemoryRouter","children","initialEntries","initialIndex","timeout","historyRef","createMemoryHistory","Router","history","PropTypes","search","hash","state","key","Navigate","to","replace","c","useNavigate","navigate","Outlet","useOutlet","Redirect","redirectChildrenType","props","propName","from","Route","element","path","startTransition","tx","useTransition","b","e","location","setLocation","timeoutMs","pending","listeningRef","value","action","push","go","listen","block","Routes","basename","caseSensitive","routes","createRoutesFromChildren","useRoutes","redirectTo","childRoutes","useLocation","f","relativeTo","resolveLocation","method","useResolvedLocation","missingTrailingSplatWarnings","warnAboutMissingTrailingSplatAt","cond","message","console","parentParams","parentPathname","parentRoute","parentPath","joinPaths","matches","matchRoutes","redirectMatch","match","generatePath","i","flattenedRoutes","flatRoutes","compilePath","matcher","target","index","r","keys","createParams","parsePath","base","flattenRoutes","rankFlattenedRoutes","parentRoutes","parentIndexes","indexes","paramRe","dynamicSegmentValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","s","computeScore","segments","initialScore","score","segment","pathScores","memo","aIndexes","aScore","bIndexes","bScore","compareIndexes","end","pattern","_","RegExp","undefined","values","paths","resolvePathname","toPathname","fromPathname","normalizeSlashes","relativeSegments","d","splat","useBlocker","when","m","k","autoUnblockingTx","retry","blocker","unblock","useHref","resolvedLocation","useMatch","p","useParams","x","B","C","M","L","F","E","u","w","G","D"],"sources":["../../packages/react-router/index.js"],"sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { createMemoryHistory, parsePath } from 'history';\n\nconst readOnly = __DEV__ ? obj => Object.freeze(obj) : obj => obj;\n\nfunction invariant(cond, message) {\n  if (!cond) throw new Error(message);\n}\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONTEXT\n///////////////////////////////////////////////////////////////////////////////\n\nconst LocationContext = React.createContext();\n\nif (__DEV__) {\n  LocationContext.Consumer.displayName = 'Location.Consumer';\n  LocationContext.Provider.displayName = 'Location.Provider';\n}\n\nconst RouteContext = React.createContext({\n  outlet: null,\n  params: readOnly({}),\n  pathname: '',\n  route: null\n});\n\nif (__DEV__) {\n  RouteContext.Consumer.displayName = 'Route.Consumer';\n  RouteContext.Provider.displayName = 'Route.Provider';\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// COMPONENTS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * A <Router> that stores all entries in memory.\n */\nexport function MemoryRouter({\n  children,\n  initialEntries,\n  initialIndex,\n  timeout\n}) {\n  let historyRef = React.useRef(null);\n\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  return (\n    <Router\n      children={children}\n      history={historyRef.current}\n      timeout={timeout}\n    />\n  );\n}\n\nif (__DEV__) {\n  MemoryRouter.displayName = 'MemoryRouter';\n  MemoryRouter.propTypes = {\n    children: PropTypes.node,\n    timeout: PropTypes.number,\n    initialEntries: PropTypes.arrayOf(\n      PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.shape({\n          pathname: PropTypes.string,\n          search: PropTypes.string,\n          hash: PropTypes.string,\n          state: PropTypes.object,\n          key: PropTypes.string\n        })\n      ])\n    ),\n    initialIndex: PropTypes.number\n  };\n}\n\n/**\n * Navigate programmatically using a component.\n */\nexport function Navigate({ to, replace = false, state }) {\n  let navigate = useNavigate();\n  navigate(to, { replace, state });\n  return null;\n}\n\nif (__DEV__) {\n  Navigate.displayName = 'Navigate';\n  Navigate.propTypes = {\n    to: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.shape({\n        pathname: PropTypes.string,\n        search: PropTypes.string,\n        hash: PropTypes.string\n      })\n    ]).isRequired,\n    replace: PropTypes.bool,\n    state: PropTypes.object\n  };\n}\n\n/**\n * Renders the child route's element, if there is one.\n */\nexport function Outlet() {\n  return useOutlet();\n}\n\nif (__DEV__) {\n  Outlet.displayName = 'Outlet';\n  Outlet.propTypes = {};\n}\n\n/**\n * Used in a route config to redirect from one location to another.\n */\nexport function Redirect() {\n  return null;\n}\n\nif (__DEV__) {\n  Redirect.displayName = 'Redirect';\n\n  function redirectChildrenType(props, propName, componentName) {\n    if (props[propName] != null) {\n      return new Error(\n        'A <Redirect> should not have child routes; they will never be rendered.'\n      );\n    }\n  }\n\n  Redirect.propTypes = {\n    children: redirectChildrenType,\n    from: PropTypes.string,\n    to: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.shape({\n        pathname: PropTypes.string,\n        search: PropTypes.string,\n        hash: PropTypes.string\n      })\n    ])\n  };\n}\n\n/**\n * Used in a route config to render an element.\n */\nexport function Route({ element }) {\n  return element;\n}\n\nif (__DEV__) {\n  Route.displayName = 'Route';\n  Route.propTypes = {\n    children: PropTypes.node,\n    element: PropTypes.element,\n    path: PropTypes.string\n  };\n}\n\n// TODO: Remove once React.useTransition is stable.\nconst startTransition = tx => tx();\nconst useTransition = React.useTransition || (() => [startTransition, false]);\n\n/**\n * The root context provider. There should be only one of these in a given app.\n */\nexport function Router({ children = null, history, timeout = 2000 }) {\n  let [location, setLocation] = React.useState(history.location);\n  let [startTransition, pending] = useTransition({ timeoutMs: timeout });\n  let listeningRef = React.useRef(false);\n\n  invariant(\n    !React.useContext(LocationContext),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You never need more than one.`\n  );\n\n  if (!listeningRef.current) {\n    listeningRef.current = true;\n    history.listen(({ location }) => {\n      startTransition(() => {\n        setLocation(location);\n      });\n    });\n  }\n\n  return (\n    <LocationContext.Provider\n      children={children}\n      value={{ history, location, pending }}\n    />\n  );\n}\n\nif (__DEV__) {\n  Router.displayName = 'Router';\n  Router.propTypes = {\n    children: PropTypes.node,\n    history: PropTypes.shape({\n      action: PropTypes.string,\n      location: PropTypes.object,\n      push: PropTypes.func,\n      replace: PropTypes.func,\n      go: PropTypes.func,\n      listen: PropTypes.func,\n      block: PropTypes.func\n    }),\n    timeout: PropTypes.number\n  };\n}\n\n/**\n * A wrapper for useRoutes that treats its children as route and/or redirect\n * objects.\n */\nexport function Routes({ basename = '', caseSensitive = false, children }) {\n  let routes = createRoutesFromChildren(children);\n  return useRoutes(routes, basename, caseSensitive);\n}\n\nif (__DEV__) {\n  Routes.displayName = 'Routes';\n  Routes.propTypes = {\n    basename: PropTypes.string,\n    caseSensitive: PropTypes.bool,\n    children: PropTypes.node\n  };\n}\n\n/**\n * Utility function that creates a routes config object from a React\n * \"children\" object, which is usually either a React element or an\n * array of elements.\n */\nexport function createRoutesFromChildren(children) {\n  let routes = [];\n\n  React.Children.forEach(children, element => {\n    // Ignore non-elements. This allows people to more\n    // easily inline conditionals in their route config.\n    if (!React.isValidElement(element)) return;\n\n    let { children, from, path, to } = element.props;\n\n    // Transparently support React.Fragment and its children.\n    if (element.type === React.Fragment) {\n      routes.push.apply(routes, createRoutesFromChildren(children));\n      return;\n    }\n\n    path = path || from || '/';\n\n    // Components that have a to prop are redirects.\n    // All others should use path + element (and maybe children) props.\n    let route;\n    if (to) {\n      route = { path, redirectTo: to };\n    } else {\n      route = { path, element };\n\n      let childRoutes = createRoutesFromChildren(children);\n      if (childRoutes.length) {\n        route.children = childRoutes;\n      }\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Blocks all navigation attempts. This is useful for preventing the page from\n * changing until some condition is met, like saving form data.\n */\nexport function useBlocker(blocker, when = true) {\n  let { history } = React.useContext(LocationContext);\n\n  // TODO: This error is probably because they somehow have\n  // 2 versions of the router loaded. We can help them understand\n  // how to avoid that.\n  invariant(\n    history != null,\n    'navigation blocking may be used only in the context of a <Router> component'\n  );\n\n  React.useEffect(() => {\n    if (when) {\n      let unblock = history.block(tx => {\n        let autoUnblockingTx = {\n          ...tx,\n          retry() {\n            // Automatically unblock the transition so it can\n            // play all the way through before retrying it.\n            // TODO: Figure out how to re-enable this block if the\n            // transition is cancelled for some reason.\n            unblock();\n            tx.retry();\n          }\n        };\n\n        blocker(autoUnblockingTx);\n      });\n\n      return unblock;\n    }\n  }, [history, when, blocker]);\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n */\nexport function useHref(to) {\n  let resolvedLocation = useResolvedLocation(to);\n  let { history } = React.useContext(LocationContext);\n\n  // TODO: This error is probably because they somehow have\n  // 2 versions of the router loaded. We can help them understand\n  // how to avoid that.\n  invariant(\n    history != null,\n    'href resolution may be used only in the context of a <Router> component'\n  );\n\n  return history.createHref(resolvedLocation);\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * NOTE: If you're using this it may mean you're doing some of your own \"routing\"\n * in your app, and we'd like to know what your use case is. We may be able to\n * provide something higher-level to better suit your needs.\n */\nexport function useLocation() {\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n */\nexport function useMatch(to) {\n  let location = useLocation();\n  let resolvedLocation = useResolvedLocation(to);\n  // TODO: Try to match search + hash as well\n  return location.pathname === resolvedLocation.pathname;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n */\nexport function useNavigate() {\n  let { history, pending } = React.useContext(LocationContext);\n  let { pathname } = React.useContext(RouteContext);\n\n  // TODO: This error is probably because they somehow have\n  // 2 versions of the router loaded. We can help them understand\n  // how to avoid that.\n  invariant(\n    history != null,\n    'navigation may be used only in the context of a <Router> component'\n  );\n\n  let navigate = React.useCallback(\n    (to, { replace, state } = {}) => {\n      if (typeof to === 'number') {\n        history.go(to);\n      } else {\n        let relativeTo = resolveLocation(to, pathname);\n\n        // If we are pending transition, use REPLACE instead of PUSH.\n        // This will prevent URLs that we started navigating to but\n        // never fully loaded from appearing in the history stack.\n        let method = !!replace || pending ? 'replace' : 'push';\n        history[method](relativeTo, state);\n      }\n    },\n    [history, pending, pathname]\n  );\n\n  return navigate;\n}\n\n/**\n * Returns the outlet element at this level of the route hierarchy. Used to\n * render child routes.\n */\nexport function useOutlet() {\n  return React.useContext(RouteContext).outlet;\n}\n\n/**\n * Returns a hash of the dynamic params that were matched in the route path.\n * This is useful for using ids embedded in the URL to fetch data, but we\n * eventually want to provide something at a higher level for this.\n */\nexport function useParams() {\n  return React.useContext(RouteContext).params;\n}\n\n/**\n * Returns a fully-resolved location object relative to the current location.\n */\nexport function useResolvedLocation(to) {\n  let { pathname } = React.useContext(RouteContext);\n  return React.useMemo(() => resolveLocation(to, pathname), [to, pathname]);\n}\n\nlet missingTrailingSplatWarnings, warnAboutMissingTrailingSplatAt;\nif (__DEV__) {\n  missingTrailingSplatWarnings = {};\n  warnAboutMissingTrailingSplatAt = (pathname, cond, message) => {\n    if (!cond && !missingTrailingSplatWarnings[pathname]) {\n      missingTrailingSplatWarnings[pathname] = true;\n      warning(false, message);\n    }\n  };\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * Route objects may take one of 2 forms:\n *\n * - { path, element, children }\n * - { path, redirectTo }\n *\n * We should probably write this up in TypeScript instead of in a comment. In\n * fact, what am I even doing here. Nobody is ever going to read this.\n */\nexport function useRoutes(routes, basename = '', caseSensitive = false) {\n  let {\n    params: parentParams,\n    pathname: parentPathname,\n    route: parentRoute\n  } = React.useContext(RouteContext);\n\n  if (warnAboutMissingTrailingSplatAt) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since\n    // we cannot even give the warning unless they land at the parent route.\n    let parentPath = parentRoute && parentRoute.path;\n    warnAboutMissingTrailingSplatAt(\n      parentPathname,\n      !parentRoute || parentRoute.path.endsWith('*'),\n      `You rendered descendant <Routes> (or called \\`useRoutes\\`) at \"${parentPathname}\"` +\n        ` (under <Route path=\"${parentPath}\">) but the parent route path has no trailing \"*\".` +\n        ` This means if you navigate deeper, the parent won't match anymore and therefore` +\n        ` the child routes will never render.` +\n        `\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route path=\"${parentPath}/*\">.`\n    );\n  }\n\n  basename = basename ? joinPaths([parentPathname, basename]) : parentPathname;\n\n  let navigate = useNavigate();\n  let location = useLocation();\n  let matches = React.useMemo(\n    () => matchRoutes(routes, location, basename, caseSensitive),\n    [routes, location, basename, caseSensitive]\n  );\n\n  if (!matches) {\n    // TODO: Warn about nothing matching, suggest using a catch-all route.\n    return null;\n  }\n\n  // If we matched a redirect, navigate and return null.\n  let redirectMatch = matches.find(match => isRedirectRoute(match.route));\n  if (redirectMatch) {\n    let { params, route } = redirectMatch;\n    let relativeTo = resolveLocation(route.redirectTo, parentPathname);\n\n    let { pathname } = relativeTo;\n    if (/:\\w+/.test(pathname)) {\n      // Allow param interpolation into <Redirect to>, e.g.\n      // <Redirect from=\"users/:id\" to=\"profile/:id\">\n      relativeTo = { ...relativeTo, pathname: generatePath(pathname, params) };\n    }\n\n    navigate(relativeTo, { replace: true });\n\n    return null;\n  }\n\n  // TODO: Initiate preload sequence here.\n\n  // Otherwise render an element.\n  let element = matches.reduceRight((outlet, { params, pathname, route }) => {\n    return (\n      <RouteContext.Provider\n        children={route.element}\n        value={{\n          outlet,\n          params: readOnly({ ...parentParams, ...params }),\n          pathname: joinPaths([basename, pathname]),\n          route\n        }}\n      />\n    );\n  }, null);\n\n  return element;\n}\n\nfunction isRedirectRoute(route) {\n  return route.redirectTo != null;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Matches the given routes to a location and returns the match data.\n */\nexport function matchRoutes(\n  routes,\n  location,\n  basename = '',\n  caseSensitive = false\n) {\n  if (typeof location === 'string') {\n    location = parsePath(location);\n  }\n\n  // TODO: Validate location\n  // - it should have a pathname\n  let base = basename.replace(/^\\/+|\\/+$/g, '');\n  let target = location.pathname.slice(1);\n\n  if (base) {\n    if (base === target) {\n      target = '';\n    } else if (target.startsWith(base)) {\n      target = target.slice(base.length).replace(/^\\/+/, '');\n    } else {\n      return null;\n    }\n  }\n\n  let flattenedRoutes = flattenRoutes(routes);\n\n  // TODO: Validate the routes config\n  // - routes should all have paths and elements\n  // - redirects should have a redirectTo\n  // - redirects should not have children\n  // - warn about unreachable routes\n\n  rankFlattenedRoutes(flattenedRoutes);\n\n  for (let i = 0; i < flattenedRoutes.length; ++i) {\n    let [path, flatRoutes] = flattenedRoutes[i];\n\n    // TODO: Match on search, state too\n    let [matcher] = compilePath(path, /* end */ true, caseSensitive);\n\n    if (matcher.test(target)) {\n      return flatRoutes.map((route, index) => {\n        let routes = flatRoutes.slice(0, index + 1);\n        let path = joinPaths(routes.map(r => r.path));\n        let [matcher, keys] = compilePath(path, /* end */ false, caseSensitive);\n        let match = target.match(matcher);\n\n        return {\n          params: createParams(keys, match.slice(2)),\n          pathname: '/' + match[1],\n          route\n        };\n      });\n    }\n  }\n\n  return null;\n}\n\nfunction flattenRoutes(\n  routes,\n  flattenedRoutes = [],\n  parentPath = '',\n  parentRoutes = [],\n  parentIndexes = []\n) {\n  routes.forEach((route, index) => {\n    let path = joinPaths([parentPath, route.path]);\n    let routes = parentRoutes.concat(route);\n    let indexes = parentIndexes.concat(index);\n\n    flattenedRoutes.push([path, routes, indexes]);\n\n    if (route.children) {\n      flattenRoutes(route.children, flattenedRoutes, path, routes, indexes);\n    }\n  });\n\n  return flattenedRoutes;\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === '*';\n\nfunction computeScore(path) {\n  let segments = path.split('/');\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  return segments\n    .filter(s => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === ''\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction rankFlattenedRoutes(flattenedRoutes) {\n  let pathScores = flattenedRoutes.reduce((memo, [path]) => {\n    memo[path] = computeScore(path);\n    return memo;\n  }, {});\n\n  flattenedRoutes.sort((a, b) => {\n    let [aPath, , aIndexes] = a;\n    let aScore = pathScores[aPath];\n\n    let [bPath, , bIndexes] = b;\n    let bScore = pathScores[bPath];\n\n    return aScore !== bScore\n      ? bScore - aScore // Higher score first\n      : compareIndexes(aIndexes, bIndexes);\n  });\n}\n\nfunction compareIndexes(a, b) {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? a[a.length - 1] - b[b.length - 1] // Earlier siblings come first\n    : 0; // It doesn't make sense to rank non-siblings by index, so they sort equal\n}\n\nfunction compilePath(path, end, caseSensitive) {\n  let keys = [];\n  let pattern =\n    '^(' +\n    path\n      .replace(/^\\/+/, '') // Ignore leading /\n      .replace(/\\*\\//g, '') // Ignore */ (from paths nested under a *)\n      .replace(/\\/?\\*?$/, '') // Ignore trailing /*, we'll handle it below\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, '\\\\$&') // Escape special regex chars\n      .replace(/:(\\w+)/g, (_, key) => {\n        keys.push(key);\n        return '([^\\\\/]+)';\n      }) +\n    ')';\n\n  if (path.endsWith('*')) {\n    if (path.endsWith('/*')) {\n      pattern += '\\\\/?'; // Don't include the / in params['*']\n    }\n    keys.push('*');\n    pattern += '(.*)';\n  } else if (end) {\n    pattern += '\\\\/?';\n  }\n\n  if (end) pattern += '$';\n\n  let flags = caseSensitive ? undefined : 'i';\n  let matcher = new RegExp(pattern, flags);\n\n  return [matcher, keys];\n}\n\nfunction createParams(keys, values) {\n  return keys.reduce((params, key, index) => {\n    // TODO: Use decodeURIComponent here to decode values?\n    params[key] = values[index];\n    return params;\n  }, {});\n}\n\nconst trimTrailingSlashes = path => path.replace(/\\/+$/, '');\nconst normalizeSlashes = path => path.replace(/\\/\\/+/g, '/');\nconst joinPaths = paths => normalizeSlashes(paths.join('/'));\nconst splitPath = path => normalizeSlashes(path).split('/');\n\nfunction resolvePathname(toPathname, fromPathname) {\n  let segments = splitPath(trimTrailingSlashes(fromPathname));\n  let relativeSegments = splitPath(toPathname);\n\n  relativeSegments.forEach(segment => {\n    if (segment === '..') {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== '.') {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? joinPaths(segments) : '/';\n}\n\n/**\n * Returns a fully resolve location object relative to the given pathname.\n */\nexport function resolveLocation(to, fromPathname = '/') {\n  let { pathname: toPathname, search = '', hash = '' } =\n    typeof to === 'string' ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith('/')\n      ? resolvePathname(toPathname, '/')\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return { pathname, search, hash };\n}\n\n/**\n * Creates a path with params interpolated.\n */\nexport function generatePath(pathname, params = {}) {\n  return pathname\n    .replace(/:(\\w+)/g, (_, key) => params[key] || `:${key}`)\n    .replace(/\\*$/, splat => params[splat] || splat);\n}\n"]},"metadata":{},"sourceType":"module"}